Description: fix DoS via missing recursion limits
Origin: backport, https://github.com/file/file/commit/0de3251fe9fdeb00ec4c6d694d4d6709f202d1ee
Origin: backport, https://github.com/file/file/commit/c0c0032b9e9eb57b91fefef905a3b018bab492d9
Origin: backport, https://github.com/file/file/commit/6f737ddfadb596d7d4a993f7ed2141ffd664a81c
Origin: backport, https://github.com/file/file/commit/90018fe22ff8b74a22fcd142225b0a00f3f12677
Origin: backport, https://github.com/file/file/commit/5063ca3a2e00c5499789ccaa1ae2a41611377b77
Origin: backport, https://github.com/file/file/commit/6bf45271eb8e0e6577b92042ce2003ba998d1686
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=773148

Index: file-5.09/doc/file.man
===================================================================
--- file-5.09.orig/doc/file.man	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/doc/file.man	2015-01-27 10:06:05.663279764 -0500
@@ -16,6 +16,7 @@
 .Op Fl F Ar separator
 .Op Fl f Ar namefile
 .Op Fl m Ar magicfiles
+.Op Fl R Ar maxrecursion
 .Ar
 .Ek
 .Nm
@@ -282,6 +283,11 @@
 Normally
 .Nm
 translates unprintable characters to their octal representation.
+.It Fl R , Fl Fl recursion Ar maxlevel
+Set the maximum recursion level for indirect type magic or name/use entry
+invocations.
+The default is
+.Dv 15 .
 .It Fl s , Fl Fl special-files
 Normally,
 .Nm
Index: file-5.09/doc/libmagic.man
===================================================================
--- file-5.09.orig/doc/libmagic.man	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/doc/libmagic.man	2015-01-27 10:06:05.663279764 -0500
@@ -37,7 +37,9 @@
 .Nm magic_setflags ,
 .Nm magic_check ,
 .Nm magic_compile ,
-.Nm magic_load
+.Nm magic_load ,
+.Nm magic_setparam ,
+.Nm magic_getparam
 .Nd Magic number recognition library
 .Sh LIBRARY
 .Lb libmagic
@@ -65,6 +67,10 @@
 .Fn magic_compile "magic_t cookie" "const char *filename"
 .Ft int
 .Fn magic_load "magic_t cookie" "const char *filename"
+.Ft int
+.Fn magic_getparam "magic_t cookie" "int param" "void *value"
+.Ft int
+.Fn magic_setparam "magic_t cookie" "int param" "const void *value"
 .Sh DESCRIPTION
 These functions
 operate on the magic database file
@@ -256,6 +262,21 @@
 .Dv NULL
 on failure.
 The
+.Fn magic_getparam
+and
+.Fn magic_setparam
+allow getting and setting various limits related to the the magic
+library.
+.Bl -column "MAGIC_PARAM_MAX_RECURSION" "size_t" "Default" -offset indent
+.It Sy "Parameter" Ta Sy "Type" Ta Sy "Default
+.It Li MAGIC_PARAM_MAX_RECURSION Ta size_t Ta 15
+.El
+The
+.Dv MAGIC_PARAM_MAX_RECURSION
+parameter controls how many levels of recursion will be followed for
+indirect magic entries or for name/use calls.
+.Pp
+The
 .Fn magic_error
 function returns a textual description of the errors of the above
 functions, or
Index: file-5.09/src/file.c
===================================================================
--- file-5.09.orig/src/file.c	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/file.c	2015-01-27 10:06:05.663279764 -0500
@@ -101,7 +101,7 @@
 #undef OPT_LONGONLY
     {0, 0, NULL, 0}
 };
-#define OPTSTRING	"bcCde:f:F:hiklLm:nNprsvz0"
+#define OPTSTRING	"bcCde:f:F:hiklLm:nNprR:svz0"
 
 private const struct {
 	const char *name;
@@ -140,6 +140,7 @@
 	size_t i;
 	int action = 0, didsomefiles = 0, errflg = 0;
 	int flags = 0, e = 0;
+	size_t max_recursion = 0;
 	struct magic_set *magic = NULL;
 	int longindex;
 	const char *magicfile = NULL;		/* where the magic is	*/
@@ -243,6 +244,9 @@
 		case 'r':
 			flags |= MAGIC_RAW;
 			break;
+		case 'R':
+			max_recursion = atoi(optarg);
+			break;
 		case 's':
 			flags |= MAGIC_DEVICES;
 			break;
@@ -290,6 +294,8 @@
 			    strerror(errno));
 			return 1;
 		}
+
+
 		switch(action) {
 		case FILE_CHECK:
 			c = magic_check(magic, magicfile);
@@ -313,6 +319,15 @@
 		if (magic == NULL)
 			if ((magic = load(magicfile, flags)) == NULL)
 				return 1;
+		if (max_recursion) {
+			if (magic_setparam(magic, MAGIC_PARAM_MAX_RECURSION,
+			    &max_recursion) == -1) {
+				(void)fprintf(stderr,
+				    "%s: Can't set recurision %s\n", progname,
+				    strerror(errno));
+				return 1;
+			}
+		}
 		break;
 	}
 
Index: file-5.09/src/file.h
===================================================================
--- file-5.09.orig/src/file.h	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/file.h	2015-01-27 10:06:05.663279764 -0500
@@ -381,6 +381,8 @@
 	/* FIXME: Make the string dynamically allocated so that e.g.
 	   strings matched in files can be longer than MAXstring */
 	union VALUETYPE ms_value;	/* either number or string */
+	size_t max_recursion;
+#define	FILE_MAX_RECURSION	15
 };
 
 /* Type for Unicode characters */
@@ -444,6 +446,14 @@
 #endif /* __EMX__ */
 
 
+typedef struct {
+	char *buf;
+	uint32_t offset;
+} file_pushbuf_t;
+
+protected file_pushbuf_t *file_push_buffer(struct magic_set *);
+protected char  *file_pop_buffer(struct magic_set *, file_pushbuf_t *);
+
 #ifndef COMPILE_ONLY
 extern const char *file_names[];
 extern const size_t file_nnames;
Index: file-5.09/src/file_opts.h
===================================================================
--- file-5.09.orig/src/file_opts.h	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/file_opts.h	2015-01-27 10:06:05.663279764 -0500
@@ -44,6 +44,7 @@
 OPT('p', "preserve-date", 0, "        preserve access times on files\n")
 #endif
 OPT('r', "raw", 0, "                  don't translate unprintable chars to \\ooo\n")
+OPT('R', "recursion", 0, "            set maximum recursion level\n")
 OPT('s', "special-files", 0, "        treat special (block/char devices) files as\n"
     "                             ordinary ones\n")
 OPT('C', "compile", 0, "              compile file specified by -m\n")
Index: file-5.09/src/funcs.c
===================================================================
--- file-5.09.orig/src/funcs.c	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/funcs.c	2015-01-27 10:06:05.663279764 -0500
@@ -458,3 +458,43 @@
 		return nm;
 	}
 }
+
+protected file_pushbuf_t *
+file_push_buffer(struct magic_set *ms)
+{
+	file_pushbuf_t *pb;
+
+	if (ms->event_flags & EVENT_HAD_ERR)
+		return NULL;
+
+	if ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)
+		return NULL;
+
+	pb->buf = ms->o.buf;
+	pb->offset = ms->offset;
+
+	ms->o.buf = NULL;
+	ms->offset = 0;
+
+	return pb;
+}
+
+protected char *
+file_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)
+{
+	char *rbuf;
+
+	if (ms->event_flags & EVENT_HAD_ERR) {
+		free(pb->buf);
+		free(pb);
+		return NULL;
+	}
+
+	rbuf = ms->o.buf;
+
+	ms->o.buf = pb->buf;
+	ms->offset = pb->offset;
+
+	free(pb);
+	return rbuf;
+}
Index: file-5.09/src/magic.c
===================================================================
--- file-5.09.orig/src/magic.c	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/magic.c	2015-01-27 10:10:09.025139942 -0500
@@ -233,6 +233,7 @@
 	ms->mlist = NULL;
 	ms->file = "unknown";
 	ms->line = 0;
+	ms->max_recursion = FILE_MAX_RECURSION;
 	return ms;
 free:
 	free(ms);
@@ -511,3 +512,29 @@
 	ms->flags = flags;
 	return 0;
 }
+
+public int
+magic_setparam(struct magic_set *ms, int param, const void *val)
+{
+	switch (param) {
+	case MAGIC_PARAM_MAX_RECURSION:
+		ms->max_recursion = *(const size_t *)val;
+		return 0;
+	default:
+		errno = EINVAL;
+		return -1;
+	}
+}
+
+public int
+magic_getparam(struct magic_set *ms, int param, void *val)
+{
+	switch (param) {
+	case MAGIC_PARAM_MAX_RECURSION:
+		*(size_t *)val = ms->max_recursion;
+		return 0;
+	default:
+		errno = EINVAL;
+		return -1;
+	}
+}
Index: file-5.09/src/magic.h
===================================================================
--- file-5.09.orig/src/magic.h	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/magic.h	2015-01-27 10:06:05.663279764 -0500
@@ -87,6 +87,10 @@
 int magic_list(magic_t, const char *);
 int magic_errno(magic_t);
 
+#define MAGIC_PARAM_MAX_RECURSION	0
+int magic_setparam(magic_t, int, const void *);
+int magic_getparam(magic_t, int, void *);
+
 #ifdef __cplusplus
 };
 #endif
Index: file-5.09/src/softmagic.c
===================================================================
--- file-5.09.orig/src/softmagic.c	2015-01-27 10:06:05.667279795 -0500
+++ file-5.09/src/softmagic.c	2015-01-27 10:06:05.663279764 -0500
@@ -43,9 +43,9 @@
 
 
 private int match(struct magic_set *, struct magic *, uint32_t,
-    const unsigned char *, size_t, int, int);
+    const unsigned char *, size_t, int, size_t);
 private int mget(struct magic_set *, const unsigned char *,
-    struct magic *, size_t, unsigned int, int);
+    struct magic *, size_t, unsigned int, size_t);
 private int magiccheck(struct magic_set *, struct magic *);
 private int32_t mprint(struct magic_set *, struct magic *);
 private int32_t moffset(struct magic_set *, struct magic *);
@@ -61,6 +61,7 @@
 private void cvt_64(union VALUETYPE *, const struct magic *);
 
 #define OFFSET_OOB(n, o, i)	((n) < (o) || (i) > ((n) - (o)))
+
 /*
  * softmagic - lookup one file in parsed, in-memory copy of database
  * Passed the name and FILE * of one file to be typed.
@@ -108,7 +109,7 @@
  */
 private int
 match(struct magic_set *ms, struct magic *magic, uint32_t nmagic,
-    const unsigned char *s, size_t nbytes, int mode, int recursion_level)
+    const unsigned char *s, size_t nbytes, int mode, size_t recursion_level)
 {
 	uint32_t magindex = 0;
 	unsigned int cont_level = 0;
@@ -1046,13 +1047,17 @@
 
 private int
 mget(struct magic_set *ms, const unsigned char *s,
-    struct magic *m, size_t nbytes, unsigned int cont_level, int recursion_level)
+    struct magic *m, size_t nbytes, unsigned int cont_level, size_t recursion_level)
 {
 	uint32_t offset = ms->offset;
+	file_pushbuf_t *pb;
+	int rv;
+	char *rbuf;
 	union VALUETYPE *p = &ms->ms_value;
 
-	if (recursion_level >= 20) {
-		file_error(ms, 0, "recursion nesting exceeded");
+	if (recursion_level >= ms->max_recursion) {
+		file_error(ms, 0, "recursion nesting (%zu) exceeded",
+		    recursion_level);
 		return -1;
 	}
 
@@ -1102,6 +1107,8 @@
 						 (q->hl[3]<<8)|(q->hl[2]));
 				break;
 			}
+			if ((ms->flags & MAGIC_DEBUG) != 0)
+				fprintf(stderr, "indirect offs=%u\n", off);
 		}
 		switch (m->in_type) {
 		case FILE_BYTE:
@@ -1542,6 +1549,8 @@
 
 		if (m->flag & INDIROFFADD) {
 			offset += ms->c.li[cont_level-1].off;
+			if ((ms->flags & MAGIC_DEBUG) != 0)
+				fprintf(stderr, "indirect +offs=%u\n", offset);
 		}
 		if (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)
 			return -1;
@@ -1611,14 +1620,38 @@
 	case FILE_INDIRECT:
 		if (offset == 0)
 			return 0;
-	  	if ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&
-		    file_printf(ms, "%s", m->desc) == -1)
-			return -1;
+
 		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
-		return file_softmagic(ms, s + offset, nbytes - offset,
+
+
+		if ((pb = file_push_buffer(ms)) == NULL)
+			return -1;
+
+		rv = file_softmagic(ms, s + offset, nbytes - offset,
 		    recursion_level, BINTEST);
 
+		if ((ms->flags & MAGIC_DEBUG) != 0)
+			fprintf(stderr, "indirect @offs=%u[%d]\n", offset, rv);
+
+		rbuf = file_pop_buffer(ms, pb);
+		if (rbuf == NULL && ms->event_flags & EVENT_HAD_ERR)
+			return -1;
+
+		if (rv == 1) {
+			if ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&
+			    file_printf(ms, m->desc, offset) == -1) {
+				free(rbuf);
+				return -1;
+			}
+			if (file_printf(ms, "%s", rbuf) == -1) {
+				free(rbuf);
+				return -1;
+			}
+		}
+		free(rbuf);
+		return rv;
+
 	case FILE_DEFAULT:	/* nothing to check */
 	default:
 		break;

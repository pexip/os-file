Description: fix denial of service via crafted CDF file
Origin: based on cdf-* patches from Debian squeeze. Backports CDF parser
 from 5.11, and fixes regression
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=664263

Index: file-5.09/src/cdf.c
===================================================================
--- file-5.09.orig/src/cdf.c	2014-02-26 10:08:06.823714048 -0500
+++ file-5.09/src/cdf.c	2014-02-26 10:08:06.819714048 -0500
@@ -35,7 +35,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: cdf.c,v 1.46 2011/09/16 21:23:59 christos Exp $")
+FILE_RCSID("@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $")
 #endif
 
 #include <assert.h>
@@ -75,6 +75,7 @@
 #define CDF_TOLE2(x)	((uint16_t)(NEED_SWAP ? _cdf_tole2(x) : (uint16_t)(x)))
 #define CDF_GETUINT32(x, y)	cdf_getuint32(x, y)
 
+
 /*
  * swap a short
  */
@@ -341,18 +342,27 @@
 cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,
     const cdf_header_t *h, cdf_secid_t id)
 {
-	assert((size_t)CDF_SEC_SIZE(h) == len);
-	return cdf_read(info, (off_t)CDF_SEC_POS(h, id),
-	    ((char *)buf) + offs, len);
+	size_t ss = CDF_SEC_SIZE(h);
+	size_t pos = CDF_SEC_POS(h, id);
+	assert(ss == len);
+	return cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);
 }
 
 ssize_t
 cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,
     size_t len, const cdf_header_t *h, cdf_secid_t id)
 {
-	assert((size_t)CDF_SHORT_SEC_SIZE(h) == len);
+	size_t ss = CDF_SHORT_SEC_SIZE(h);
+	size_t pos = CDF_SHORT_SEC_POS(h, id);
+	assert(ss == len);
+	if (pos > CDF_SEC_SIZE(h) * sst->sst_len) {
+		DPRINTF(("Out of bounds read %" SIZE_T_FORMAT "u > %"
+		    SIZE_T_FORMAT "u\n",
+		    pos, CDF_SEC_SIZE(h) * sst->sst_len));
+		return -1;
+	}
 	(void)memcpy(((char *)buf) + offs,
-	    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);
+	    ((const char *)sst->sst_tab) + pos, len);
 	return len;
 }
 
@@ -419,8 +429,8 @@
 			if (sec < 0)
 				goto out;
 			if (i >= sat->sat_len) {
-			    DPRINTF(("Out of bounds reading MSA %u >= %u",
-				i, sat->sat_len));
+			    DPRINTF(("Out of bounds reading MSA %" SIZE_T_FORMAT
+				"u >= %" SIZE_T_FORMAT "u", i, sat->sat_len));
 			    errno = EFTYPE;
 			    goto out2;
 			}
@@ -493,7 +503,8 @@
 		}
 		if (i >= scn->sst_len) {
 			DPRINTF(("Out of bounds reading long sector chain "
-			    "%u > %u\n", i, scn->sst_len));
+			    "%" SIZE_T_FORMAT "u > %" SIZE_T_FORMAT "u\n", i,
+			    scn->sst_len));
 			errno = EFTYPE;
 			goto out;
 		}
@@ -538,7 +549,8 @@
 		}
 		if (i >= scn->sst_len) {
 			DPRINTF(("Out of bounds reading short sector chain "
-			    "%u > %u\n", i, scn->sst_len));
+			    "%" SIZE_T_FORMAT "u > %" SIZE_T_FORMAT "u\n",
+			    i, scn->sst_len));
 			errno = EFTYPE;
 			goto out;
 		}
@@ -646,7 +658,8 @@
 		}
 		if (i >= ssat->sat_len) {
 			DPRINTF(("Out of bounds reading short sector chain "
-			    "%u > %u\n", i, ssat->sat_len));
+			    "%" SIZE_T_FORMAT "u > %" SIZE_T_FORMAT "u\n", i,
+			    ssat->sat_len));
 			errno = EFTYPE;
 			goto out;
 		}
@@ -786,17 +799,18 @@
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
+		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
 		q = (const uint8_t *)(const void *)
-		    ((const char *)(const void *)p +
-		    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);
+		    ((const char *)(const void *)p + ofs
+		    - 2 * sizeof(uint32_t));
 		if (q > e) {
 			DPRINTF(("Ran of the end %p > %p\n", q, e));
 			goto out;
 		}
 		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
 		inp[i].pi_type = CDF_GETUINT32(q, 0);
-		DPRINTF(("%d) id=%x type=%x offs=%x,%d\n", i, inp[i].pi_id,
-		    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));
+		DPRINTF(("%" SIZE_T_FORMAT "u) id=%x type=%x offs=0x%tx,0x%x\n",
+		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
 		if (inp[i].pi_type & CDF_VECTOR) {
 			nelements = CDF_GETUINT32(q, 1);
 			o = 2;
@@ -842,6 +856,20 @@
 			(void)memcpy(&u64, &q[o4], sizeof(u64));
 			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
 			break;
+		case CDF_FLOAT:
+			if (inp[i].pi_type & CDF_VECTOR)
+				goto unknown;
+			(void)memcpy(&u32, &q[o4], sizeof(u32));
+			u32 = CDF_TOLE4(u32);
+			memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));
+			break;
+		case CDF_DOUBLE:
+			if (inp[i].pi_type & CDF_VECTOR)
+				goto unknown;
+			(void)memcpy(&u64, &q[o4], sizeof(u64));
+			u64 = CDF_TOLE8((uint64_t)u64);
+			memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));
+			break;
 		case CDF_LENGTH32_STRING:
 		case CDF_LENGTH32_WSTRING:
 			if (nelements > 1) {
@@ -857,17 +885,22 @@
 				*info = inp;
 				inp = *info + nelem;
 			}
-			DPRINTF(("nelements = %d\n", nelements));
+			DPRINTF(("nelements = %" SIZE_T_FORMAT "u\n",
+			    nelements));
 			for (j = 0; j < nelements; j++, i++) {
 				uint32_t l = CDF_GETUINT32(q, o);
 				inp[i].pi_str.s_len = l;
 				inp[i].pi_str.s_buf = (const char *)
 				    (const void *)(&q[o4 + sizeof(l)]);
-				DPRINTF(("l = %d, r = %d, s = %s\n", l,
+				DPRINTF(("l = %d, r = %" SIZE_T_FORMAT
+				    "u, s = %s\n", l,
 				    CDF_ROUND(l, sizeof(l)),
 				    inp[i].pi_str.s_buf));
-				l = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));
-				o += l >> 2;
+				if (l & 1)
+					l++;
+				o += l >> 1;
+				if (q + o >= e)
+					goto out;
 				o4 = o * sizeof(uint32_t);
 			}
 			i--;
@@ -886,7 +919,7 @@
 		unknown:
 			DPRINTF(("Don't know how to deal with %x\n",
 			    inp[i].pi_type));
-			goto out;
+			break;
 		}
 	}
 	return 0;
@@ -925,8 +958,9 @@
 			return -1;
 		}
 		if (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),
-		    info, count, &maxcount) == -1)
+		    info, count, &maxcount) == -1) {
 			return -1;
+		}
 	}
 	return 0;
 }
@@ -1051,14 +1085,14 @@
 	size_t i, j, s = size / sizeof(cdf_secid_t);
 
 	for (i = 0; i < sat->sat_len; i++) {
-		(void)fprintf(stderr, "%s[%" SIZE_T_FORMAT "u]:\n%.6d: ",
-		    prefix, i, i * s);
+		(void)fprintf(stderr, "%s[%" SIZE_T_FORMAT "u]:\n%.6"
+		    SIZE_T_FORMAT "u: ", prefix, i, i * s);
 		for (j = 0; j < s; j++) {
 			(void)fprintf(stderr, "%5d, ",
 			    CDF_TOLE4(sat->sat_tab[s * i + j]));
 			if ((j + 1) % 10 == 0)
-				(void)fprintf(stderr, "\n%.6d: ",
-				    i * s + j + 1);
+				(void)fprintf(stderr, "\n%.6" SIZE_T_FORMAT
+				    "u: ", i * s + j + 1);
 		}
 		(void)fprintf(stderr, "\n");
 	}
@@ -1077,7 +1111,8 @@
 		if (j == 16) {
 			j = 0;
 			abuf[15] = '\0';
-			(void)fprintf(stderr, "%s\n%.4x: ", abuf, i + 1);
+			(void)fprintf(stderr, "%s\n%.4" SIZE_T_FORMAT "x: ",
+			    abuf, i + 1);
 		}
 	}
 	(void)fprintf(stderr, "\n");
@@ -1175,6 +1210,14 @@
 			(void)fprintf(stderr, "unsigned 32 [%u]\n",
 			    info[i].pi_u32);
 			break;
+		case CDF_FLOAT:
+			(void)fprintf(stderr, "float [%g]\n",
+			    info[i].pi_f);
+			break;
+		case CDF_DOUBLE:
+			(void)fprintf(stderr, "double [%g]\n",
+			    info[i].pi_d);
+			break;
 		case CDF_LENGTH32_STRING:
 			(void)fprintf(stderr, "string %u [%.*s]\n",
 			    info[i].pi_str.s_len,
Index: file-5.09/src/cdf.h
===================================================================
--- file-5.09.orig/src/cdf.h	2014-02-26 10:08:06.823714048 -0500
+++ file-5.09/src/cdf.h	2014-02-26 10:08:06.819714048 -0500
@@ -51,136 +51,140 @@
 
 #define CDF_SECID_NULL					0
 #define CDF_SECID_FREE					-1
-#define	CDF_SECID_END_OF_CHAIN				-2
-#define	CDF_SECID_SECTOR_ALLOCATION_TABLE		-3
+#define CDF_SECID_END_OF_CHAIN				-2
+#define CDF_SECID_SECTOR_ALLOCATION_TABLE		-3
 #define CDF_SECID_MASTER_SECTOR_ALLOCATION_TABLE	-4
 
 typedef struct {
-        uint64_t	h_magic;
+	uint64_t	h_magic;
 #define CDF_MAGIC	0xE11AB1A1E011CFD0LL
-        uint64_t	h_uuid[2];
-        uint16_t	h_revision;
-        uint16_t	h_version;
-        uint16_t	h_byte_order;
-        uint16_t	h_sec_size_p2;
-        uint16_t	h_short_sec_size_p2;
-        uint8_t		h_unused0[10];
-        uint32_t	h_num_sectors_in_sat;
-        uint32_t	h_secid_first_directory;
-        uint8_t		h_unused1[4];
-        uint32_t	h_min_size_standard_stream;
-        cdf_secid_t	h_secid_first_sector_in_short_sat;
-        uint32_t	h_num_sectors_in_short_sat;
-        cdf_secid_t	h_secid_first_sector_in_master_sat;
-        uint32_t	h_num_sectors_in_master_sat;
-        cdf_secid_t	h_master_sat[436/4];
+	uint64_t	h_uuid[2];
+	uint16_t	h_revision;
+	uint16_t	h_version;
+	uint16_t	h_byte_order;
+	uint16_t	h_sec_size_p2;
+	uint16_t	h_short_sec_size_p2;
+	uint8_t		h_unused0[10];
+	uint32_t	h_num_sectors_in_sat;
+	uint32_t	h_secid_first_directory;
+	uint8_t		h_unused1[4];
+	uint32_t	h_min_size_standard_stream;
+	cdf_secid_t	h_secid_first_sector_in_short_sat;
+	uint32_t	h_num_sectors_in_short_sat;
+	cdf_secid_t	h_secid_first_sector_in_master_sat;
+	uint32_t	h_num_sectors_in_master_sat;
+	cdf_secid_t	h_master_sat[436/4];
 } cdf_header_t;
 
-#define CDF_SEC_SIZE(h)	(1 << (h)->h_sec_size_p2)
+#define CDF_SEC_SIZE(h) ((size_t)(1 << (h)->h_sec_size_p2))
 #define CDF_SEC_POS(h, secid) (CDF_SEC_SIZE(h) + (secid) * CDF_SEC_SIZE(h))
-#define CDF_SHORT_SEC_SIZE(h)	(1 << (h)->h_short_sec_size_p2)
+#define CDF_SHORT_SEC_SIZE(h)	((size_t)(1 << (h)->h_short_sec_size_p2))
 #define CDF_SHORT_SEC_POS(h, secid) ((secid) * CDF_SHORT_SEC_SIZE(h))
 
-typedef int32_t	cdf_dirid_t;
+typedef int32_t cdf_dirid_t;
 #define CDF_DIRID_NULL	-1
 
-typedef int64_t	cdf_timestamp_t;
+typedef int64_t cdf_timestamp_t;
 #define CDF_BASE_YEAR	1601
 #define CDF_TIME_PREC	10000000
 
 typedef struct {
-        uint16_t	d_name[32];
-        uint16_t	d_namelen;
-        uint8_t		d_type;
+	uint16_t	d_name[32];
+	uint16_t	d_namelen;
+	uint8_t		d_type;
 #define CDF_DIR_TYPE_EMPTY		0
-#define	CDF_DIR_TYPE_USER_STORAGE	1
-#define	CDF_DIR_TYPE_USER_STREAM	2
-#define	CDF_DIR_TYPE_LOCKBYTES		3
-#define	CDF_DIR_TYPE_PROPERTY		4
-#define	CDF_DIR_TYPE_ROOT_STORAGE	5
-        uint8_t		d_color;
+#define CDF_DIR_TYPE_USER_STORAGE	1
+#define CDF_DIR_TYPE_USER_STREAM	2
+#define CDF_DIR_TYPE_LOCKBYTES		3
+#define CDF_DIR_TYPE_PROPERTY		4
+#define CDF_DIR_TYPE_ROOT_STORAGE	5
+	uint8_t		d_color;
 #define CDF_DIR_COLOR_READ	0
 #define CDF_DIR_COLOR_BLACK	1
-        cdf_dirid_t	d_left_child;
-        cdf_dirid_t	d_right_child;
-        cdf_dirid_t	d_storage;
-        uint64_t	d_storage_uuid[2];
-        uint32_t	d_flags;
-        cdf_timestamp_t	d_created;
-        cdf_timestamp_t	d_modified;
-        cdf_secid_t	d_stream_first_sector;
-        uint32_t	d_size;
-        uint32_t	d_unused0;
+	cdf_dirid_t	d_left_child;
+	cdf_dirid_t	d_right_child;
+	cdf_dirid_t	d_storage;
+	uint64_t	d_storage_uuid[2];
+	uint32_t	d_flags;
+	cdf_timestamp_t d_created;
+	cdf_timestamp_t d_modified;
+	cdf_secid_t	d_stream_first_sector;
+	uint32_t	d_size;
+	uint32_t	d_unused0;
 } cdf_directory_t;
 
 #define CDF_DIRECTORY_SIZE	128
 
 typedef struct {
-        cdf_secid_t *sat_tab;
-        size_t sat_len;
+	cdf_secid_t *sat_tab;
+	size_t sat_len;
 } cdf_sat_t;
 
 typedef struct {
-        cdf_directory_t *dir_tab;
-        size_t dir_len;
+	cdf_directory_t *dir_tab;
+	size_t dir_len;
 } cdf_dir_t;
 
 typedef struct {
-        void *sst_tab;
-        size_t sst_len;
-        size_t sst_dirlen;
+	void *sst_tab;
+	size_t sst_len;
+	size_t sst_dirlen;
 } cdf_stream_t;
 
 typedef struct {
-        uint32_t	cl_dword;
-        uint16_t	cl_word[2];
-        uint8_t		cl_two[2];
-        uint8_t		cl_six[6];
+	uint32_t	cl_dword;
+	uint16_t	cl_word[2];
+	uint8_t		cl_two[2];
+	uint8_t		cl_six[6];
 } cdf_classid_t;
 
 typedef struct {
-        uint16_t	si_byte_order;
-        uint16_t	si_zero;
-        uint16_t	si_os_version;
-        uint16_t	si_os;
-        cdf_classid_t	si_class;
-        uint32_t	si_count;
+	uint16_t	si_byte_order;
+	uint16_t	si_zero;
+	uint16_t	si_os_version;
+	uint16_t	si_os;
+	cdf_classid_t	si_class;
+	uint32_t	si_count;
 } cdf_summary_info_header_t;
 
 #define CDF_SECTION_DECLARATION_OFFSET 0x1c
 
 typedef struct {
-        cdf_classid_t	sd_class;
-        uint32_t	sd_offset;
+	cdf_classid_t	sd_class;
+	uint32_t	sd_offset;
 } cdf_section_declaration_t;
 
 typedef struct {
-        uint32_t	sh_len;
-        uint32_t	sh_properties;
+	uint32_t	sh_len;
+	uint32_t	sh_properties;
 } cdf_section_header_t;
 
 typedef struct {
-        uint32_t	pi_id;
-        uint32_t	pi_type;
-        union {
-                uint16_t	_pi_u16;
-                int16_t		_pi_s16;
-                uint32_t	_pi_u32;
-                int32_t		_pi_s32;
-                uint64_t	_pi_u64;
-                int64_t		_pi_s64;
-                cdf_timestamp_t	_pi_tp;
-                struct {
-                        uint32_t s_len;
-                        const char *s_buf;
-                } _pi_str;
-        } pi_val;
+	uint32_t	pi_id;
+	uint32_t	pi_type;
+	union {
+		uint16_t	_pi_u16;
+		int16_t		_pi_s16;
+		uint32_t	_pi_u32;
+		int32_t		_pi_s32;
+		uint64_t	_pi_u64;
+		int64_t		_pi_s64;
+		cdf_timestamp_t _pi_tp;
+		float		_pi_f;
+		double		_pi_d;
+		struct {
+			uint32_t s_len;
+			const char *s_buf;
+		} _pi_str;
+	} pi_val;
 #define pi_u64	pi_val._pi_u64
 #define pi_s64	pi_val._pi_s64
 #define pi_u32	pi_val._pi_u32
 #define pi_s32	pi_val._pi_s32
 #define pi_u16	pi_val._pi_u16
 #define pi_s16	pi_val._pi_s16
+#define pi_f	pi_val._pi_f
+#define pi_d	pi_val._pi_d
 #define pi_tp	pi_val._pi_tp
 #define pi_str	pi_val._pi_str
 } cdf_property_info_t;
@@ -189,13 +193,13 @@
 
 /* Variant type definitions */
 #define CDF_EMPTY		0x00000000
-#define	CDF_NULL		0x00000001
+#define CDF_NULL		0x00000001
 #define CDF_SIGNED16		0x00000002
 #define CDF_SIGNED32		0x00000003
 #define CDF_FLOAT		0x00000004
 #define CDF_DOUBLE		0x00000005
 #define CDF_CY			0x00000006
-#define	CDF_DATE		0x00000007
+#define CDF_DATE		0x00000007
 #define CDF_BSTR		0x00000008
 #define CDF_DISPATCH		0x00000009
 #define CDF_ERROR		0x0000000a
@@ -206,7 +210,7 @@
 #define CDF_SIGNED8		0x00000010
 #define CDF_UNSIGNED8		0x00000011
 #define CDF_UNSIGNED16		0x00000012
-#define	CDF_UNSIGNED32		0x00000013
+#define CDF_UNSIGNED32		0x00000013
 #define CDF_SIGNED64		0x00000014
 #define CDF_UNSIGNED64		0x00000015
 #define CDF_INT			0x00000016
@@ -241,7 +245,7 @@
 #define CDF_PROPERTY_SUBJECT			0x00000003
 #define CDF_PROPERTY_AUTHOR			0x00000004
 #define CDF_PROPERTY_KEYWORDS			0x00000005
-#define CDF_PROPERTY_COMMENTS                   0x00000006
+#define CDF_PROPERTY_COMMENTS			0x00000006
 #define CDF_PROPERTY_TEMPLATE			0x00000007
 #define CDF_PROPERTY_LAST_SAVED_BY		0x00000008
 #define CDF_PROPERTY_REVISION_NUMBER		0x00000009
@@ -258,9 +262,9 @@
 #define CDF_PROPERTY_LOCALE_ID			0x80000000
 
 typedef struct {
-        int i_fd;
-        const unsigned char *i_buf;
-        size_t i_len;
+	int i_fd;
+	const unsigned char *i_buf;
+	size_t i_len;
 } cdf_info_t;
 
 struct timespec;
Index: file-5.09/src/cdf_time.c
===================================================================
--- file-5.09.orig/src/cdf_time.c	2014-02-26 10:08:06.823714048 -0500
+++ file-5.09/src/cdf_time.c	2014-02-26 10:08:06.819714048 -0500
@@ -121,7 +121,7 @@
 	tm.tm_year = (int)(CDF_BASE_YEAR + (t / 365));
 
 	rdays = cdf_getdays(tm.tm_year);
-	t -= rdays;
+	t -= rdays - 1;
 	tm.tm_mday = cdf_getday(tm.tm_year, (int)t);
 	tm.tm_mon = cdf_getmonth(tm.tm_year, (int)t);
 	tm.tm_wday = 0;
Index: file-5.09/src/readcdf.c
===================================================================
--- file-5.09.orig/src/readcdf.c	2014-02-26 10:08:06.823714048 -0500
+++ file-5.09/src/readcdf.c	2014-02-26 10:09:53.471716904 -0500
@@ -26,7 +26,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: readcdf.c,v 1.26 2011/08/26 13:38:28 christos Exp $")
+FILE_RCSID("@(#)$File: readcdf.c,v 1.28 2012/02/17 05:27:45 christos Exp $")
 #endif
 
 #include <stdlib.h>
@@ -72,6 +72,16 @@
                             info[i].pi_u32) == -1)
                                 return -1;
                         break;
+                case CDF_FLOAT:
+                        if (NOTMIME(ms) && file_printf(ms, ", %s: %g", buf,
+                            info[i].pi_f) == -1)
+                                return -1;
+                        break;
+                case CDF_DOUBLE:
+                        if (NOTMIME(ms) && file_printf(ms, ", %s: %g", buf,
+                            info[i].pi_d) == -1)
+                                return -1;
+                        break;
                 case CDF_LENGTH32_STRING:
                 case CDF_LENGTH32_WSTRING:
                         len = info[i].pi_str.s_len;
@@ -144,6 +154,8 @@
         if (!NOTMIME(ms)) {
 		if (str == NULL)
 			return 0;
+                if (file_printf(ms, "application/%s", str) == -1)
+                        return -1;
         }
         return 1;
 }
@@ -161,30 +173,31 @@
                 return -1;
 
         if (NOTMIME(ms)) {
-                if (file_printf(ms, "Composite Document File V2 Document") == -1)
+                if (file_printf(ms, "Composite Document File V2 Document")
+		    == -1)
                         return -1;
 
                 if (file_printf(ms, ", %s Endian",
                     si.si_byte_order == 0xfffe ?  "Little" : "Big") == -1)
-                        return -1;
+                        return -2;
                 switch (si.si_os) {
                 case 2:
                         if (file_printf(ms, ", Os: Windows, Version %d.%d",
                             si.si_os_version & 0xff,
                             (uint32_t)si.si_os_version >> 8) == -1)
-                                return -1;
+                                return -2;
                         break;
                 case 1:
                         if (file_printf(ms, ", Os: MacOS, Version %d.%d",
                             (uint32_t)si.si_os_version >> 8,
                             si.si_os_version & 0xff) == -1)
-                                return -1;
+                                return -2;
                         break;
                 default:
                         if (file_printf(ms, ", Os %d, Version: %d.%d", si.si_os,
                             si.si_os_version & 0xff,
                             (uint32_t)si.si_os_version >> 8) == -1)
-                                return -1;
+                                return -2;
                         break;
                 }
         }
@@ -192,7 +205,7 @@
         m = cdf_file_property_info(ms, info, count);
         free(info);
 
-        return m;
+        return m == -1 ? -2 : m;
 }
 
 protected int
@@ -261,7 +274,7 @@
 #ifdef CDF_DEBUG
         cdf_dump_summary_info(&h, &scn);
 #endif
-        if ((i = cdf_file_summary_info(ms, &h, &scn)) == -1)
+        if ((i = cdf_file_summary_info(ms, &h, &scn)) < 0)
                 expn = "Can't expand summary_info";
 	if (i == 0) {
 		const char *str = "vnd.ms-office";
@@ -272,7 +285,7 @@
 		    d = &dir.dir_tab[j];
 		    for (k = 0; k < sizeof(name); k++)
 			name[k] = (char)cdf_tole2(d->d_name[k]);
-		    if (strstr(name, "WordDocument") == 0) {
+		    if (strstr(name, "WordDocument") != 0) {
 			str = "msword";
 			break;
 		    }
@@ -292,8 +305,10 @@
         free(sat.sat_tab);
 out0:
         if (i != 1) {
-                if (file_printf(ms, "Composite Document File V2 Document") == -1)
-                        return -1;
+		if (i == -1)
+		    if (file_printf(ms, "Composite Document File V2 Document")
+			== -1)
+			    return -1;
                 if (*expn)
                         if (file_printf(ms, ", %s%s", corrupt, expn) == -1)
                                 return -1;
